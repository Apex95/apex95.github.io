I"Á<p><em>Ok, I‚Äôve been missing for a few days‚Ä¶months‚Ä¶almost a year. Ran out of ideas and time for new articles (thanks to the university) so I‚Äôll publish some stuff related to numerical methods, starting with a basic <strong>interpolation</strong> method using the <strong>Lagrange Polynomial</strong>. And since there‚Äôs a lot of C# here, I thought it would be a good idea, for ‚Äúprogramming diversity‚Äù, to write this in <strong>Matlab/Octave</strong>. Forgive me guys :/</em></p>

<h2 id="the-lagrange-polynomial">The Lagrange Polynomial</h2>

<p>This <strong>Lagrange Polynomial</strong> is a function (curve) that you create, that goes through a specific set of points (the basic interpolation rule).</p>

<p>For <strong>N</strong> sets of points (<strong>x y</strong>) the general formula is the one below:</p>

<script type="math/tex; mode=display">Y(x) = \sum_{i=1}^{n} y_i \cdot \prod_{j=1, j \neq i} \frac{x-x_j}{x_i-x_j}</script>

<p>Now a sum of products may look intimidating, but it‚Äôs a really simple method - whatever is not needed is cancelled (in this case multiplied with 0) so it won‚Äôt change the final result unless it‚Äôs necessary.</p>

<p>Don‚Äôt worry if you don‚Äôt understand the formula, take a look at the example below, it should be way clearer after.</p>

<h2 id="example--explaination">Example &amp; Explaination</h2>

<p>Let‚Äôs take the‚Ä¶ factorial function (<strong>x!</strong>) and try to write a <strong>Lagrange Polynomial</strong> that produces ‚Äúsimilar‚Äù results.<br />
<em>It won‚Äôt produce very precise outputs since we gave it a low number of points - don‚Äôt expect miracles</em>.</p>

<p>Given this set of <strong>4 points</strong>:</p>

<table cellpading="3" style="border-collapse:collapse;text-align:center;color:#444;" border="1" cellpadding="6" cellspacing="10">

<tbody>

<tr>

<td><strong>x</strong></td>

<td><strong>y</strong></td>

</tr>

<tr>

<td>2</td>

<td>2</td>

</tr>

<tr>

<td>3</td>

<td>6</td>

</tr>

<tr>

<td>4</td>

<td>24</td>

</tr>

<tr>

<td>5</td>

<td>120</td>

</tr>

</tbody>

</table>

<p>We construct the polynomial this way (using <strong>Lagrange Multipliers</strong>)</p>

<script type="math/tex; mode=display">{\color{Red} {2}} \cdot \frac{(x-3)(x-4)(x-5)}{(2-3)(2-4)(2-5)} + {\color{Red}{6}} \cdot \frac{(x-2)(x-4)(x-5)}{(3-2)(3-4)(3-5)} + {\color{Red}{24}} \cdot \frac{(x-2)(x-3)(x-5)}{(4-2)(4-3)(4-5)} + {\color{Red}{120}} \cdot \frac{(x-2)(x-3)(x-4)}{(5-2)(5-3)(5-4)}</script>

<p>Notice that if <strong>x</strong> is equal to one of the <strong>known values</strong> (from the table), many of these fractions will be <strong>0</strong> and only <strong>one of them</strong> will be <strong>1</strong>. That <strong>1</strong> is multiplied with the expected output and you get the result.</p>

<p>For <strong>x = 2</strong>: the equation becomes: <strong>2 * 1 + 6 * 0 + 24 * 0 + 120 * 0</strong> = 2. Got the point? This ensures us that no matter what, the graph of this function will go through our set of points and since this polynomial will have an order &lt;= n-1, there‚Äôs no need to worry about any edges.</p>

<p>After creating the polynomial and testing it, we may find out that‚Ä¶we‚Äôll need more than 4 points to obtain a good approximation of the factorial function.</p>

<p>You can see below a <strong>plot</strong> that contains the <span style="color:red">Lagrange Polynomial</span> and the <span style="color:green">values computed with Gamma function</span>(or the correct factorial values).</p>

<figure class="image">
  <img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" data-echo="/imgs/posts/matlab-octave-lagrange-interpolation-polynomial/3.png" alt="Comparing the Lagrange approximation (Red) with the Gamma function (Green)." />
  <figcaption><p>Comparing the Lagrange approximation (Red) with the Gamma function (Green).</p>
</figcaption>
</figure>

<p>And this is for inputs <strong>inside the interval</strong> of known values <strong>[2;5]</strong> - for values greater than 5 or lower than 2, the function still works but the outputs are completely wrong since there are no points to guide the curve.</p>

<p>Still it provides exact values for 2!, 3!, 4! and 5!</p>

<figure class="image">
  <img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" data-echo="/imgs/posts/matlab-octave-lagrange-interpolation-polynomial/4.png" alt="Meh..." />
  <figcaption><p>Meh‚Ä¶</p>
</figcaption>
</figure>

<h2 id="matlaboctave-sourcecode">Matlab/Octave Sourcecode</h2>

<p>Here goes the code:</p>

<p>```matlabfunction [y] = lagrange(x, x0, y0)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>% x0 - vector containing inputs (x values)
% y0 - vector containing outputs (results for these x values
% x - value you want to compute, for interpolation
% y - computed value

n = size(x0, 1); 
y = 0;

for i=1:n
    p = 1;
    for j=1:n

        if j == i   % avoiding fancy division by 0
            continue;
        endif;

        p *= (x-x0(j)) / (x0(i)-x0(j));

    endfor;

    y += y0(i) * p;   
endfor; endfunction; ```
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="conclusions">Conclusions</h2>

<p>Pretty useful to approximate another polynomials, not that great when it comes to ‚Äúunusual‚Äù functions - it requires many known points in order to work‚Ä¶precisely =&gt; pretty bad for a <strong>predictor</strong>. Maybe the factorial function is not the best example here, since it‚Äôs not that easy to approximate it, but I chose it for simplicity.</p>

<p>On the bright side: might be a nice way to approximate factorials for non-natural numbers.</p>
:ET