I"Œ<p>This post targets to underline the <strong>predictability</strong> of the randomâ€¦ or better said <strong>pseudo-random number generator</strong> exposed by the <strong>.NET</strong> framework (aka the <code class="highlighter-rouge">Random()</code> class), under certain assumptions. Because of the nature of the implementation, <strong>100% accuracy</strong> can be obtained with a fairly simple idea and a rather short code snippet.</p>

<h5 id="the-presented-method-definitely-isnt-something-new-in-the-domain-of-cryptography-however-the-purpose-of-the-article-is-to-bring-awareness-and-avoid-including-this-specific-weakness-of-the-algorithm-in-critical-sections-of-your-projects">The presented method definitely isnâ€™t something new in the domain of Cryptography, however the purpose of the article is to bring awareness and avoid including this specific weakness of the algorithm in critical sections of your projects.</h5>

<p>The following scenario is considered:</p>

<ul>
  <li><strong>no access</strong> to the <strong>processâ€™s memory</strong></li>
  <li>must work for <strong>any chosen seed</strong></li>
</ul>

<h2 id="the-random-class">The Random class</h2>

<p>While many pseudo-random implementations (e.g., libcâ€™s <code class="highlighter-rouge">rand()</code>) rely on a <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Generator (LCG)</a> which generates each number in the sequence by taking into account the previous one, I discovered that <strong>.NET</strong>â€™s <strong>random number generator</strong> uses a different approach.</p>

<p>By looking at the implementation of the <code class="highlighter-rouge">Random()</code> class (<a href="https://referencesource.microsoft.com/#mscorlib/system/random.cs">available here</a>), one can easily observe that pseudo-random number generation is based on a <a href="https://rosettacode.org/wiki/Subtractive_generator">Subtractive Generator</a></p>

<p>using System;</p>

<p>public class Program
{
	public static int revertOutput(double output)
	{
		return (int)(output * Int32.MaxValue);
	}</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static double computeDiffAndOffset(double r1, double r2)
{
	double diff = r1 - r2;
	
	if (diff == Int32.MaxValue)
		diff=- 1/(double)Int32.MaxValue;
	if (diff &lt; 0)
		return diff + 1;
	else
		return diff;
}

public static void Main()
{
	// targeted Random class
	Random r = new Random();
	
	// array used for storing states of the subtractive generator
	double[] SeedArray = new double[56];
	
	// leaking the state by observing the first 55 random numbers
	for (int i = 1; i &lt; 56; i++)
		SeedArray[i] = r.NextDouble();
	
	// the offset is known from the original implementation
	int offset = 21;
	
	// indices used to address certain states in the array
	int index1 = 1, index2 = index1 + offset;
	
	// number of random doubles to predict
	for (int i = 0; i &lt; 1000; i++)
	{
		if (index1 &gt;= 56)
			index1 = 1;
		
		if (index2 &gt;= 56)
			index2 = 1;
		
		double predictedValue = computeDiffAndOffset(SeedArray[index1], SeedArray[index2]);

		double correctRandom =  r.NextDouble();
		
		if (Math.Abs(predictedValue - correctRandom) &gt; 0.00001)
		{
			Console.WriteLine("failed");
			Console.WriteLine(predictedValue + " vs " + correctRandom);
		}

		SeedArray[index1] = predictedValue;
		
		index1++;
		index2++;
	}
} }
</code></pre></div></div>
:ET