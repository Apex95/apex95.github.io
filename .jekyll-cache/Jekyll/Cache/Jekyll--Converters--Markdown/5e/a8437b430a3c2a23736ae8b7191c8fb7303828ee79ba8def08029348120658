I"….<p>This post targets to underline the <strong>predictability</strong> of the randomâ€¦ or better said <strong>pseudo-random number generator</strong> (PRNG) exposed by the <strong>.NET</strong> framework (aka the <code class="highlighter-rouge">Random()</code> class), under certain assumptions. Because of the nature of the implementation, <strong>100% accuracy</strong> can be obtained with a fairly simple idea and a rather short code snippet.</p>

<h5 id="the-presented-method-definitely-isnt-something-new-in-the-domain-of-cryptography-however-the-purpose-of-the-article-is-to-bring-awareness-about-this-specific-weakness-of-the-algorithm-in-critical-sections-of-your-projects">The presented method definitely isnâ€™t something new in the domain of Cryptography, however the purpose of the article is to bring awareness about this specific weakness of the algorithm in critical sections of your projects.</h5>

<p>The following scenario is considered:</p>

<ul>
  <li><strong>no access</strong> to the <strong>processâ€™s memory</strong></li>
  <li>must work for <strong>any chosen seed</strong></li>
  <li>a limited set of generated <strong>random numbers</strong> is <strong>visible</strong> to the attacker</li>
  <li>we focus on <code class="highlighter-rouge">Random.nextDouble()</code> as there is no data loss because <strong>int casting</strong></li>
</ul>

<p>Iâ€™ll be presenting a short summary of the algorithm used by <code class="highlighter-rouge">Random()</code> and how can we predict the random numbers. If you feel like going directly to code and proof-of-concept, scroll to the bottom of the article.</p>

<h2 id="the-random-class">The Random class</h2>

<p>While many pseudo-random implementations (e.g., libcâ€™s <code class="highlighter-rouge">rand()</code>) rely on a <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Generator (LCG)</a> which generates each number in the sequence by taking into account the previous one, I discovered that <strong>.NET</strong>â€™s <strong>random number generator</strong> uses a different approach.</p>

<p>By looking at the implementation of the <code class="highlighter-rouge">Random()</code> class (<a href="https://referencesource.microsoft.com/#mscorlib/system/random.cs">available here</a>), one can easily observe that pseudo-random number generation is based on a <a href="https://rosettacode.org/wiki/Subtractive_generator">Subtractive Generator</a>, which permits the user to specify a custom seed or use <code class="highlighter-rouge">Environment.TickCount</code> (systemâ€™s uptime in milliseconds) as default.</p>

<p>The core of the pseudo-random generator is the <code class="highlighter-rouge">InternalSample()</code> (line #100) method which constructs the sequence of numbers. <code class="highlighter-rouge">Random.nextDouble()</code> will actually call the <code class="highlighter-rouge">Sample()</code> method which returns the value of <code class="highlighter-rouge">InternalSample()</code> divided by <code class="highlighter-rouge">Int32.MaxValue</code>, as this is claimed to improve the distribution of random numbers.
Without going into much details regarding the included gimmicks, we can describe the generator as follows:</p>

<script type="math/tex; mode=display">R_i = R_i - R_j, j=i+21</script>

<script type="math/tex; mode=display">R_i = \left\{\begin{matrix}
R_i - 1, if (R_i = Int32.Max)\\ 
R_i, else
\end{matrix}\right.</script>

<script type="math/tex; mode=display">% <![CDATA[
R_i = \left\{\begin{matrix}
R_i + Int32.Max, if (R_i < 0)\\ 
R_i, if (R_i \geqslant 0)
\end{matrix}\right. %]]></script>

<script type="math/tex; mode=display">retVal = \frac{R_i}{Int32.Max}</script>

<p>where <script type="math/tex">R_i</script> is a â€˜stateâ€™ of the algorithm and <script type="math/tex">retVal</script> is, obviously, the returned value.</p>

<p>To store the state of the pseudo-random number generator, a <strong>circular array</strong> of <strong>56 ints</strong> is employed - this means <script type="math/tex">i</script> and <script type="math/tex">j</script> will get re-initialized to <strong>1</strong> whenever they exceed the length of the array - however the <strong>offset</strong> of <strong>21</strong> remains constant.</p>

<h2 id="predicting-random-numbers">Predicting Random Numbers</h2>

<p>In my opinion, it seems rather difficult to determine the starting state of the algorithm without knowing the seed. Butâ€¦ we notice that the algorithm is outputting pseudo-random numbers which properly describe each value of its state array.</p>

<p>In other words, if we have access to a randomly generated number <script type="math/tex">retVal</script>, we can compute <script type="math/tex">R_i</script> and <script type="math/tex">R_i</script> is used to generate future numbers in the sequence. However, we will need values for <script type="math/tex">i = 1,55</script> in order to cover all the properties.</p>

<h5 id="if-we-manage-to-leak-a-continuous-set-of-55-generated-numbers-we-have-enough-information-to-describe-and-construct-a-new-generator-which-will-output-the-same-numbers-as-the-original-but-can-be-used-as-a-predictor">If we manage to leak a continuous set of <strong>55</strong> generated numbers, we have enough information to describe and construct a new generator which will output the same numbers as the original but can be used as a predictor.</h5>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="code"><pre>			
<span class="k">public</span> <span class="k">class</span> <span class="nc">RandomNumberPredictor</span>
<span class="p">{</span>	
	<span class="k">public</span> <span class="k">static</span> <span class="kt">double</span> <span class="nf">computeDiffAndOffset</span><span class="p">(</span><span class="kt">double</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">r2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">double</span> <span class="n">diff</span> <span class="p">=</span> <span class="n">r1</span> <span class="p">-</span> <span class="n">r2</span><span class="p">;</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="p">==</span> <span class="n">Int32</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">)</span>
			<span class="n">diff</span><span class="p">=-</span> <span class="m">1</span><span class="p">/(</span><span class="kt">double</span><span class="p">)</span><span class="n">Int32</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">diff</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">Random</span> <span class="n">r</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="p">();</span>
		<span class="kt">double</span><span class="p">[]</span> <span class="n">SeedArray</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">56</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">56</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
			<span class="n">SeedArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="nf">NextDouble</span><span class="p">();</span>
		
		<span class="kt">int</span> <span class="n">offset</span> <span class="p">=</span> <span class="m">21</span><span class="p">;</span>
		
		<span class="c1">// indices used to address certain states in the array
</span>
		<span class="kt">int</span> <span class="n">index1</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">index2</span> <span class="p">=</span> <span class="n">index1</span> <span class="p">+</span> <span class="n">offset</span><span class="p">;</span>
		
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index1</span> <span class="p">&gt;=</span> <span class="m">56</span><span class="p">)</span>
				<span class="n">index1</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">index2</span> <span class="p">&gt;=</span> <span class="m">56</span><span class="p">)</span>
				<span class="n">index2</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
			
			<span class="kt">double</span> <span class="n">predictedValue</span> <span class="p">=</span> <span class="nf">computeDiffAndOffset</span><span class="p">(</span><span class="n">SeedArray</span><span class="p">[</span><span class="n">index1</span><span class="p">],</span> <span class="n">SeedArray</span><span class="p">[</span><span class="n">index2</span><span class="p">]);</span>

			<span class="kt">double</span> <span class="n">correctRandom</span> <span class="p">=</span>  <span class="n">r</span><span class="p">.</span><span class="nf">NextDouble</span><span class="p">();</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="n">predictedValue</span> <span class="p">-</span> <span class="n">correctRandom</span><span class="p">)</span> <span class="p">&gt;</span> <span class="m">0.00001</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"failed"</span><span class="p">);</span>
				<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">predictedValue</span> <span class="p">+</span> <span class="s">" vs "</span> <span class="p">+</span> <span class="n">correctRandom</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">SeedArray</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="p">=</span> <span class="n">predictedValue</span><span class="p">;</span>
			
			<span class="n">index1</span><span class="p">++;</span>
			<span class="n">index2</span><span class="p">++;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>
:ET