I"¨-<p>Soâ€¦ Iâ€™ll try to explain here the concept of <strong>gradient descent</strong> as simple as possible in order to provide some insight of whatâ€™s happening from a mathematical perspective and why the formula works. Iâ€™ll try to keep it short and split this into 2 <em>chapters</em>: <strong>theory</strong> and <strong>example</strong> - take it as a ELI5 linear regression tutorial.</p>

<p>Feel free to skip the mathy stuff and jump directly to the <strong>example</strong> if you feel that it might be easier to understand.</p>

<h2 id="theory-and-formula">Theory and Formula</h2>

<p>For the sake of simplicity, weâ€™ll work in the <strong>1D</strong> space: weâ€™ll optimize a function that has only one <strong>coefficient</strong> so it is easier to plot and comprehend.
The function can look like this:</p>

\[f(x) = w \cdot x + 2\]

<p>where we have to determine the value of \(w\) such that the function successfully matches / approximates a set of known points.</p>

<p>Since our interest is to find the best coefficient, weâ€™ll consider \(w\) as a <strong>variable</strong> in our formulas and while computing the derivatives; \(x\) will be treated as a <strong>constant</strong>. In other words, we donâ€™t compute the <strong>derivative</strong> with respect to \(x\) since we donâ€™t want to find values for it - we already have a set of inputs for the function, weâ€™re not allowed to change them.</p>

<p>To properly grasp the gradient descent, as an optimization method, you need to know the following mathematical fact:</p>

<ul>
  <li>The <strong>derivative</strong> of a function is <span style="color:green">positive</span> when the function <span style="color:green">increases</span> and is <span style="color:red">negative</span> when the function <span style="color:red">decreases</span>.</li>
</ul>

<p>And writing this mathematicallyâ€¦</p>

\[\frac{\mathrm{d} }{\mathrm{d} w}f(w) {\color{Green}&gt; 0} \rightarrow  f(w) {\color{Green}\nearrow }\]

\[\frac{\mathrm{d} }{\mathrm{d} w}f(w) {\color{Red}&lt; 0} \rightarrow  f(w) {\color{Red}\swarrow }\]

<p>This is happening because the derivative can be seen as the slope of a functionâ€™s plot at a given point. I wonâ€™t go into details here, but check out the graph below - it should help.</p>

<p><em>Why is this important?</em></p>

<p>Because, as you probably know already, <strong>gradient descent</strong> attempts to <span style="color:red">minimize</span> the <strong>error function</strong> (aka cost function).</p>

<p>Now, assuming we use the <strong>MSE</strong> (Mean Squared Error) function, we have something that looks like this:</p>

\[\hat{y_i} = f(x_i)\]

\[MSE = \frac{1}{n} \cdot \sum_{i=1}^{i=n}{(y_i - \hat{y_i})^2}\]

<p>Where: \(y_i\) is the correct value, \(\hat{y_i}\) is the current (computed) value and \(n\) is the number of points weâ€™re using to compute the \(MSE\).</p>

<h5 id="the-mse-is-always-positive-since-its-a-sum-of-squared-values-and-therefore-has-a-known-minimum-which-is-0---so-it-can-be-minimized-using-the-aforementioned-method">The <strong>MSE</strong> is <strong>always positive</strong> (since itâ€™s a sum of squared values) and therefore has a <strong>known minimum</strong>, which is <strong>0</strong> - so it can be <span style="color:red">minimized</span> using the aforementioned method.</h5>

<p>Take a look at the plot below: the <strong>sign</strong> of the <strong>slope</strong> provides useful information of where the <strong>minimum</strong> of the function is. We can use the value of the <strong>slope</strong> (the derivative) to adjust the value of the coefficient <strong>w</strong> (i.e.: <code class="highlighter-rouge">w = w - slope</code>).</p>

<figure class="image">
  <img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" data-echo="/imgs/posts/gradient-descent-simply-explained-with-example/mse-slope-plot.png" alt="&lt;p&gt;The sign of the slope can be used to locate the functionâ€™s minimum value.&lt;/p&gt;
" />
  <figcaption><p>The sign of the slope can be used to locate the functionâ€™s minimum value.</p>
</figcaption>
</figure>

<p>Time to compute the derivative. Before that, I must warn you: itâ€™s quite a <em>long</em> formula but I tried to do it step by step. Behold!</p>

\[\frac{\mathrm{d}}{\mathrm{d} w}MSE = \frac{\mathrm{d}}{\mathrm{d} w} (\frac{1}{n} \cdot \sum_{i=1}^{i=n}{(y_i - \hat{y_i})^2}) =\]

\[= \frac{1}{n} \cdot \frac{\mathrm{d}}{\mathrm{d} w} (\sum_{i=1}^{i=n}{(y_i - \hat{y_i})^2}) =\]

\[= \frac{1}{n} \cdot \sum_{i=1}^{i=n}{\frac{\mathrm{d}}{\mathrm{d} w}((y_i - \hat{y_i})^2}) =\]

\[= \frac{1}{n} \cdot \sum_{i=1}^{i=n}{\frac{\mathrm{d}}{\mathrm{d} w}((y_i - \hat{y_i})^2}) =\]

\[= \frac{2}{n} \cdot \sum_{i=1}^{i=n}{(y_i - \hat{y_i})} \cdot (-1) \cdot \frac{\mathrm{d \hat{y_i}}}{\mathrm{d} w}\]

<p>Phew. 
From here, youâ€™d have to replace \(\frac{\mathrm{d \hat{y_i}}}{\mathrm{d} w}\) with the derivative of the function you chose to optimize. For \(\hat{y} = w \cdot x + 2\), we get:</p>

\[= \frac{2}{n} \cdot \sum_{i=1}^{i=n}{(y_i - \hat{y_i})} \cdot (-1) \cdot x\]

<p>And thatâ€™s about it. You can now update the values of your coefficient \(w\) using the following formula:</p>

\[w = w - learning\_rate \cdot \frac{\mathrm{d }}{\mathrm{d} w}MSE(w)\]

<h2 id="example">Example</h2>

<p>Weâ€™ll do the example in a <strong>2D</strong> space, in order to represent a basic <strong>linear regression</strong> (a <strong>Perceptron</strong> without an activation function). 
Given the function below:</p>

\[f(x) = w_1 \cdot x + w_2\]

<p>we have to find \(w_1\) and \(w_2\), using <strong>gradient descent</strong>, so it approximates the following set of points:</p>

\[f(1) = 5, f(2) = 7\]

<p>We start by writing the <strong>MSE</strong>:</p>

\[MSE = \frac{1}{n} \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x + w_2))^2}\]

<p>And then the differentiation part. Since there are <strong>2 coefficients</strong>, we compute <strong>partial derivatives</strong> - each one corresponds to its coefficient.</p>

<p>For \(w_1\):</p>

\[\frac{\partial}{\partial w_1} (\frac{1}{n} \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x_i + w_2))^2}) =\]

\[= \frac{1}{n} \cdot \sum_{i=1}^{i=2}{(y_i - \frac{\partial}{\partial w_1}(w_1 \cdot x_i + w_2))^2} =\]

\[= \frac{1}{n} \cdot 2 \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x_i + w_2)) \cdot (-1) \cdot x_i} =\]

\[= -\frac{2}{n} \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x_i + w_2)) \cdot x_i}\]

<p>For \(w_2\):</p>

\[\frac{\partial}{\partial w_2} (\frac{1}{n} \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x_i + w_2))^2}) =\]

\[= -\frac{2}{n} \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x_i + w_2))}\]

<p>Now, we pick some <strong>random</strong> values for our coefficients. Letâ€™s say \(w_1 = 9\) and \(w_2 = 10\).</p>

<p>We compute:</p>

\[f(1) = 9 \cdot 1 + 10 = 19, f(2) = 9 \cdot 2 + 10 = 28\]

<p>Obviously, these are not the outputs weâ€™re looking for, so weâ€™ll continue by adjusting the coefficients (weâ€™ll consider a <strong>0.15</strong> learning rate):</p>

\[w_1 = w_1 - learning\_rate \cdot \frac{\partial}{\partial w_1} MSE =\]

\[= 9 + 0.15 \cdot \frac{2}{2} \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x_i + w_2)) \cdot x_i} =\]

\[= 9 + 0.15 \cdot ((5 - (9 \cdot 1 + 10)) \cdot 1 + (7 - (9 \cdot 2 + 10)) \cdot 2) =\]

\[= 9 - 0.15 \cdot 56 = 0.6\]

\[w_2 = w_2 - learning\_rate \cdot \frac{\partial}{\partial w_2} MSE =\]

\[= 10 + 0.15 \cdot \frac{2}{2} \cdot \sum_{i=1}^{i=2}{(y_i - (w_1 \cdot x_i + w_2))} =\]

\[= 10 + 0.15 \cdot ((5 - (9 \cdot 1 + 10)) + (7 - (9 \cdot 2 + 10))) =\]

\[= 10 - 0.15 \cdot 35 = 4.75\]

<p>Recalculating the output of our function, we observe that the outputs are somehow closer to our expected values.</p>

\[f(1) = 0.6 \cdot 1 + 4.75 = 5.35, f(2) = 0.6 \cdot 2 + 1.25 = 5.95\]

<p>Running a second step of optimization:</p>

\[w_1 = 0.6 + 0.15 \cdot ((5 - (0.6 \cdot 1 + 4.75)) \cdot 1 + (7 - (0.6 \cdot 2 + 4.75)) \cdot 2) =\]

\[= 0.6 + 0.15 \cdot 1.75 = 0.86\]

\[w_2 = 4.75 + 0.15 \cdot ((5 - (0.6 \cdot 1 + 4.75)) + (7 - (0.6 \cdot 2 + 4.75))) =\]

\[= 4.75 + 0.15 \cdot 0.7 = 4.85\]

<p>Now, this is going to take multiple iterations in order to converge and weâ€™re not going to do everything by hand.
Writing this formula as a Python script yields the following results:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre>1: w1 = 9.000, w2 = 10.000, MSE: 318.5 
   f(1) = 19.000, f(2) = 28.000
------------------------------------------------
2: w1 = 0.600, w2 = 4.750, MSE: 0.6125 
   f(1) = 5.350, f(2) = 5.950
------------------------------------------------
3: w1 = 0.862, w2 = 4.855, MSE: 0.345603125 
   f(1) = 5.718, f(2) = 6.580
------------------------------------------------
4: w1 = 0.881, w2 = 4.810, MSE: 0.330451789063 
   f(1) = 5.691, f(2) = 6.572
------------------------------------------------
5: w1 = 0.906, w2 = 4.771, MSE: 0.316146225664 
   f(1) = 5.676, f(2) = 6.582
------------------------------------------------
6: w1 = 0.929, w2 = 4.732, MSE: 0.302460106908 
   f(1) = 5.662, f(2) = 6.591
------------------------------------------------
7: w1 = 0.953, w2 = 4.694, MSE: 0.289366466781 
   f(1) = 5.647, f(2) = 6.600
------------------------------------------------
8: w1 = 0.976, w2 = 4.657, MSE: 0.276839656487 
   f(1) = 5.633, f(2) = 6.609
------------------------------------------------
9: w1 = 0.998, w2 = 4.621, MSE: 0.264855137696 
   f(1) = 5.619, f(2) = 6.617


[...]


------------------------------------------------
195: w1 = 1.984, w2 = 3.026, MSE: 7.04866766459e-05 
     f(1) = 5.010, f(2) = 6.994
------------------------------------------------
196: w1 = 1.984, w2 = 3.026, MSE: 6.74352752985e-05 
     f(1) = 5.010, f(2) = 6.994
------------------------------------------------
197: w1 = 1.984, w2 = 3.025, MSE: 6.45159705491e-05 
     f(1) = 5.010, f(2) = 6.994
------------------------------------------------
198: w1 = 1.985, w2 = 3.025, MSE: 6.17230438739e-05 
     f(1) = 5.009, f(2) = 6.994
------------------------------------------------
199: w1 = 1.985, w2 = 3.024, MSE: 5.90510243065e-05 
     f(1) = 5.009, f(2) = 6.994
------------------------------------------------
200: w1 = 1.985, w2 = 3.024, MSE: 5.64946777215e-05 
     f(1) = 5.009, f(2) = 6.994
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It converges to \(w_1 = 2\) and \(w_2 = 3\) which are, indeed, the coefficients we were looking for.</p>

<p>In practice, I recommend experimenting with <strong>smaller</strong> learning rates and more iterations - large learning rates can lead to <strong>divergence</strong> (the coefficients stray from their correct values and tend to plus or minus infinity).</p>

<h2 id="conclusion">Conclusion</h2>

<p>I guess this is all. Reading it now, I think it might take more than 5 minutes butâ€¦ I guess itâ€™s still a short article when compared to others that discuss the same subject :))</p>

<p>I hope this proves useful as a starting point and youâ€™ve got something out of it. <strong>Backpropagation</strong> of errors in <strong>nerual networks</strong> works in a similar fashion, although the number of dimensions is way larger than what was presented here. Aaand it contains some additional features in order to handle <strong>non-convex</strong> functions (and avoid getting stuck in <strong>local minima</strong>). Maybe in other article weâ€™ll take a look at those, too.</p>
:ET